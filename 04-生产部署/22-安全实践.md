# ç¬¬22ç« ï¼šå®‰å…¨å®è·µ

> ä¿æŠ¤RAGç³»ç»Ÿå®‰å…¨ï¼Œé˜²èŒƒå¸¸è§å®‰å…¨å¨èƒ

---

## ğŸ“š ç« èŠ‚æ¦‚è¿°

æœ¬ç« å°†å­¦ä¹ å¦‚ä½•ä¸ºRAGç³»ç»Ÿå®æ–½å…¨é¢çš„å®‰å…¨æªæ–½ï¼Œä¿æŠ¤æ•°æ®å’Œç³»ç»Ÿå®‰å…¨ã€‚

### å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬ç« åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… ç†è§£RAGç³»ç»Ÿçš„å®‰å…¨å¨èƒ
- âœ… å®æ–½APIè®¤è¯å’Œæˆæƒ
- âœ… ä¿æŠ¤æ•æ„Ÿæ•°æ®
- âœ… é˜²èŒƒå¸¸è§æ”»å‡»
- âœ… å®æ–½å®‰å…¨æ‰«æ
- âœ… æ»¡è¶³åˆè§„è¦æ±‚

### é¢„è®¡æ—¶é—´

- ç†è®ºå­¦ä¹ ï¼š50åˆ†é’Ÿ
- å®è·µæ“ä½œï¼š60-90åˆ†é’Ÿ
- æ€»è®¡ï¼šçº¦2-3å°æ—¶

---

## 1. å®‰å…¨å¨èƒåˆ†æ

### 1.1 å¸¸è§å¨èƒ

**OWASP Top 10**ï¼š
1. **æ³¨å…¥æ”»å‡»**ï¼šSQLæ³¨å…¥ã€NoSQLæ³¨å…¥
2. **è®¤è¯å¤±æ•ˆ**ï¼šå¼±å¯†ç ã€ä¼šè¯ç®¡ç†ä¸å½“
3. **æ•æ„Ÿæ•°æ®æ³„éœ²**ï¼šæœªåŠ å¯†çš„æ•æ„Ÿä¿¡æ¯
4. **XMLå¤–éƒ¨å®ä½“ï¼ˆXXEï¼‰**
5. **è®¿é—®æ§åˆ¶å¤±æ•ˆ**
6. **å®‰å…¨é…ç½®é”™è¯¯**
7. **è·¨ç«™è„šæœ¬æ”»å‡»ï¼ˆXSSï¼‰**
8. **ä¸å®‰å…¨çš„ååºåˆ—åŒ–**
9. **ä½¿ç”¨å«æœ‰å·²çŸ¥æ¼æ´çš„ç»„ä»¶**
10. **æ—¥å¿—è®°å½•å’Œç›‘æ§ä¸è¶³

### 1.2 RAGç³»ç»Ÿç‰¹å®šå¨èƒ

**æ•°æ®å®‰å…¨**ï¼š
- ç”¨æˆ·æŸ¥è¯¢æ•°æ®æ³„éœ²
- æ–‡æ¡£å†…å®¹æœªæˆæƒè®¿é—®
- APIå¯†é’¥æ³„éœ²

**LLMå®‰å…¨**ï¼š
- æç¤ºæ³¨å…¥æ”»å‡»
- æ•°æ®æå–æ”»å‡»
- æ¨¡å‹è¶Šç‹±

**ç³»ç»Ÿå®‰å…¨**ï¼š
- DoSæ”»å‡»
- èµ„æºè€—å°½
- æ¶æ„æŸ¥è¯¢

---

## 2. APIè®¤è¯å’Œæˆæƒ

### 2.1 JWTè®¤è¯

```python
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from datetime import datetime, timedelta
import jwt

app = FastAPI()

# JWTé…ç½®
SECRET_KEY = "your-secret-key-here"  # ä»ç¯å¢ƒå˜é‡è¯»å–
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

security = HTTPBearer()

def create_access_token(data: dict, expires_delta: timedelta = None):
    """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """éªŒè¯ä»¤ç‰Œ"""
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials",
            )
        return payload
    except jwt.PyJWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
        )

# ç™»å½•ç«¯ç‚¹
@app.post("/token")
async def login(username: str, password: str):
    """è·å–è®¿é—®ä»¤ç‰Œ"""
    # éªŒè¯ç”¨æˆ·ï¼ˆå®é™…åº”è¯¥æŸ¥è¯¢æ•°æ®åº“ï¼‰
    if username == "admin" and password == "secret":
        access_token = create_access_token(
            data={"sub": username},
            expires_delta=timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        )
        return {"access_token": access_token, "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
        )

# å—ä¿æŠ¤çš„ç«¯ç‚¹
@app.get("/protected")
async def protected_route(payload: dict = Depends(verify_token)):
    """éœ€è¦è®¤è¯çš„ç«¯ç‚¹"""
    return {"message": f"Hello {payload['sub']}"}
```

### 2.2 APIå¯†é’¥è®¤è¯

```python
from fastapi import Header, HTTPException

async def verify_api_key(x_api_key: str = Header(...)):
    """éªŒè¯APIå¯†é’¥"""
    valid_keys = os.getenv("VALID_API_KEYS", "").split(",")

    if x_api_key not in valid_keys:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API key"
        )
    return x_api_key

@app.get("/query")
async def query(
    text: str,
    api_key: str = Depends(verify_api_key)
):
    """éœ€è¦APIå¯†é’¥çš„æŸ¥è¯¢ç«¯ç‚¹"""
    return {"result": "answer"}
```

### 2.3 OAuth2

```python
from fastapi.security import OAuth2PasswordBearer
from fastapi.security.oauth2 import OAuth2

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.get("/users/me")
async def read_users_me(token: str = Depends(oauth2_scheme)):
    """OAuth2è®¤è¯"""
    return {"token": token}
```

---

## 3. æ•°æ®ä¿æŠ¤

### 3.1 æ•æ„Ÿæ•°æ®åŠ å¯†

```python
from cryptography.fernet import Fernet
import os

# åŠ å¯†å¯†é’¥ï¼ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼‰
ENCRYPTION_KEY = os.getenv("ENCRYPTION_KEY")
cipher_suite = Fernet(ENCRYPTION_KEY)

def encrypt_data(data: str) -> bytes:
    """åŠ å¯†æ•°æ®"""
    return cipher_suite.encrypt(data.encode())

def decrypt_data(encrypted_data: bytes) -> str:
    """è§£å¯†æ•°æ®"""
    return cipher_suite.decrypt(encrypted_data).decode()

# ä½¿ç”¨ç¤ºä¾‹
@api.post("/store-sensitive-data")
async def store_sensitive_data(data: str):
    """å­˜å‚¨æ•æ„Ÿæ•°æ®"""
    # åŠ å¯†åå†å­˜å‚¨
    encrypted = encrypt_data(data)

    # å­˜å‚¨åˆ°æ•°æ®åº“
    await db.execute(
        "INSERT INTO sensitive_data (encrypted_data) VALUES ($1)",
        encrypted
    )

    return {"status": "stored"}

@api.get("/retrieve-sensitive-data")
async def retrieve_sensitive_data(id: int):
    """æ£€ç´¢æ•æ„Ÿæ•°æ®"""
    # ä»æ•°æ®åº“è·å–åŠ å¯†æ•°æ®
    encrypted = await db.fetch_one(
        "SELECT encrypted_data FROM sensitive_data WHERE id = $1",
        id
    )

    # è§£å¯†
    decrypted = decrypt_data(encrypted['encrypted_data'])

    return {"data": decrypted}
```

### 3.2 ç¯å¢ƒå˜é‡ç®¡ç†

```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    """åº”ç”¨é…ç½®"""

    # APIé…ç½®
    API_KEY: str
    API_SECRET: str

    # æ•°æ®åº“é…ç½®
    DATABASE_URL: str

    # LLM APIé…ç½®
    OPENAI_API_KEY: str

    # åŠ å¯†é…ç½®
    ENCRYPTION_KEY: str

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()

# ä½¿ç”¨
@app.get("/")
async def root():
    return {
        "api_configured": bool(settings.API_KEY),
        "llm_configured": bool(settings.OPENAI_API_KEY)
    }
```

### 3.3 Secretç®¡ç†ï¼ˆK8sï¼‰

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: rag-secrets
type: Opaque
stringData:
  api-key: "your-api-key"
  openai-api-key: "sk-xxxxx"
  encryption-key: "your-encryption-key"
```

```python
# åœ¨K8sä¸­è¯»å–Secret
import os

api_key = os.getenv("API_KEY")  # ä»SecretæŒ‚è½½çš„ç¯å¢ƒå˜é‡è¯»å–
```

---

## 4. è¾“å…¥éªŒè¯å’Œæ¸…ç†

### 4.1 è¾“å…¥éªŒè¯

```python
from pydantic import BaseModel, validator, Field
from typing import Optional

class QueryRequest(BaseModel):
    """æŸ¥è¯¢è¯·æ±‚æ¨¡å‹"""

    text: str = Field(..., min_length=1, max_length=2000)
    top_k: Optional[int] = Field(5, ge=1, le=20)
    temperature: Optional[float] = Field(0.7, ge=0.0, le=2.0)

    @validator('text')
    def validate_text(cls, v):
        """éªŒè¯æ–‡æœ¬å†…å®¹"""
        # æ£€æŸ¥å±é™©å­—ç¬¦
        dangerous_patterns = ['<script>', 'javascript:', 'onerror=']
        for pattern in dangerous_patterns:
            if pattern.lower() in v.lower():
                raise ValueError(f"Dangerous pattern detected: {pattern}")

        # é™åˆ¶é•¿åº¦
        if len(v) > 2000:
            raise ValueError("Text too long")

        return v.strip()

@app.post("/query")
async def query(request: QueryRequest):
    """å®‰å…¨çš„æŸ¥è¯¢ç«¯ç‚¹"""
    result = await rag_query(request.text, request.top_k)
    return result
```

### 4.2 SQLæ³¨å…¥é˜²æŠ¤

```python
from sqlalchemy import text

# âŒ ä¸å®‰å…¨ï¼šå­—ç¬¦ä¸²æ‹¼æ¥
async def unsafe_query(user_id: str):
    query = f"SELECT * FROM users WHERE id = '{user_id}'"  # å±é™©ï¼
    return await db.execute(query)

# âœ… å®‰å…¨ï¼šå‚æ•°åŒ–æŸ¥è¯¢
async def safe_query(user_id: str):
    query = text("SELECT * FROM users WHERE id = :user_id")
    return await db.execute(query, {"user_id": user_id})
```

### 4.3 XSSé˜²æŠ¤

```python
from fastapi.responses import JSONResponse
import html

def sanitize_output(text: str) -> str:
    """æ¸…ç†è¾“å‡ºæ–‡æœ¬"""
    return html.escape(text)

@app.get("/search")
async def search(query: str):
    """æœç´¢ç«¯ç‚¹ï¼ˆé˜²XSSï¼‰"""
    results = await search_documents(query)

    # æ¸…ç†è¾“å‡º
    safe_results = []
    for result in results:
        safe_results.append({
            "title": sanitize_output(result['title']),
            "content": sanitize_output(result['content'][:200])
        })

    return JSONResponse(content=safe_results)
```

---

## 5. æç¤ºæ³¨å…¥é˜²æŠ¤

### 5.1 è¯†åˆ«æ”»å‡»

```python
import re

def detect_prompt_injection(user_input: str) -> bool:
    """æ£€æµ‹æç¤ºæ³¨å…¥æ”»å‡»"""

    # å¸¸è§æ³¨å…¥æ¨¡å¼
    injection_patterns = [
        r"ignore (all )?(previous|above) instructions?",
        r"forget (everything|all instructions)",
        r"override (your )?(programming|instructions)",
        r"disregard (previous|above)",
        r"instead of",
        r"new instructions?",
        r"system:",
        r"\[SYSTEM\]",
        r"<SYSTEM>",
        r"<script>",
        r"<iframe>",
    ]

    user_input_lower = user_input.lower()

    for pattern in injection_patterns:
        if re.search(pattern, user_input_lower, re.IGNORECASE):
            return True

    return False

@app.post("/chat")
async def chat(message: str):
    """èŠå¤©ç«¯ç‚¹ï¼ˆé˜²æ³¨å…¥ï¼‰"""
    if detect_prompt_injection(message):
        raise HTTPException(
            status_code=400,
            detail="Invalid input detected"
        )

    response = await generate_response(message)
    return response
```

### 5.2 è¾“å‡ºè¿‡æ»¤

```python
def filter_llm_output(output: str) -> str:
    """è¿‡æ»¤LLMè¾“å‡º"""

    # ç§»é™¤ç³»ç»ŸæŒ‡ä»¤æ³„éœ²
    filtered = re.sub(
        r"(As an AI|I am an AI|I'm an AI).+?(?=\n\n|$)",
        "[Filtered]",
        output,
        flags=re.DOTALL
    )

    # ç§»é™¤JSON/ä»£ç ç»“æ„ï¼ˆå¯èƒ½åŒ…å«æŒ‡ä»¤ï¼‰
    filtered = re.sub(
        r"\{.*?\"system.*?:.*?\}",
        "[Filtered]",
        filtered,
        flags=re.DOTALL
    )

    return filtered
```

---

## 6. é€Ÿç‡é™åˆ¶

### 6.1 ä»¤ç‰Œæ¡¶ç®—æ³•

```python
from fastapi import HTTPException, Request
from datetime import datetime, timedelta
import asyncio

class RateLimiter:
    """é€Ÿç‡é™åˆ¶å™¨"""

    def __init__(self, max_calls: int, time_window: int):
        self.max_calls = max_calls  # æœ€å¤§è°ƒç”¨æ¬¡æ•°
        self.time_window = time_window  # æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
        self.calls = {}  # {key: [timestamp1, timestamp2, ...]}

    async def is_allowed(self, key: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å…è®¸è°ƒç”¨"""
        now = datetime.utcnow()

        # è·å–è¯¥keyçš„è°ƒç”¨è®°å½•
        if key not in self.calls:
            self.calls[key] = []

        # ç§»é™¤æ—¶é—´çª—å£å¤–çš„è®°å½•
        self.calls[key] = [
            call_time for call_time in self.calls[key]
            if (now - call_time).total_seconds() < self.time_window
        ]

        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        if len(self.calls[key]) >= self.max_calls:
            return False

        # è®°å½•æœ¬æ¬¡è°ƒç”¨
        self.calls[key].append(now)
        return True

# å…¨å±€é€Ÿç‡é™åˆ¶å™¨
rate_limiter = RateLimiter(max_calls=100, time_window=60)

@app.post("/query")
async def query(request: Request, text: str):
    """å¸¦é€Ÿç‡é™åˆ¶çš„æŸ¥è¯¢"""
    client_ip = request.client.host

    if not await rate_limiter.is_allowed(client_ip):
        raise HTTPException(
            status_code=429,
            detail="Too many requests"
        )

    result = await rag_query(text)
    return result
```

### 6.2 Redisé€Ÿç‡é™åˆ¶

```python
import redis

redis_client = redis.Redis(host='localhost', port=6379, db=0)

async def check_rate_limit_redis(
    key: str,
    max_calls: int,
    time_window: int
) -> bool:
    """ä½¿ç”¨Redisæ£€æŸ¥é€Ÿç‡é™åˆ¶"""

    pipe = redis_client.pipeline()
    now = datetime.utcnow().timestamp()

    # ç§»é™¤æ—¶é—´çª—å£å¤–çš„è®°å½•
    pipe.zremrangebyscore(key, 0, now - time_window)

    # è·å–å½“å‰è®¡æ•°
    pipe.zcard(key)

    # æ·»åŠ æœ¬æ¬¡è°ƒç”¨
    pipe.zadd(key, {str(now): now})

    # è®¾ç½®è¿‡æœŸæ—¶é—´
    pipe.expire(key, time_window)

    results = pipe.execute()
    current_count = results[1]

    return current_count < max_calls
```

---

## 7. å®‰å…¨æ‰«æ

### 7.1 ä¾èµ–æ¼æ´æ‰«æ

```bash
# ä½¿ç”¨pip-auditæ‰«æPythonä¾èµ–
pip install pip-audit
pip-audit

# ä½¿ç”¨Safetyæ‰«æ
pip install safety
safety check
```

### 7.2 Dockeré•œåƒæ‰«æ

```bash
# ä½¿ç”¨Trivyæ‰«æé•œåƒ
trivy image rag-api:latest

# åœ¨CI/CDä¸­é›†æˆ
# .github/workflows/security.yml
- name: Run Trivy vulnerability scanner
  uses: aquasecurity/trivy-action@master
  with:
    scan-type: 'image'
    image-ref: 'rag-api:latest'
    format: 'sarif'
    output: 'trivy-results.sarif'
```

### 7.3 ä»£ç å®‰å…¨æ‰«æ

```bash
# ä½¿ç”¨Banditæ‰«æPythonä»£ç 
pip install bandit
bandit -r app/

# ä½¿ç”¨Semgrep
semgrep --config=auto app/
```

---

## 8. å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šå®æ–½è®¤è¯

**ä»»åŠ¡**ï¼š
1. æ·»åŠ JWTè®¤è¯
2. ä¿æŠ¤æ•æ„Ÿç«¯ç‚¹
3. å®ç°tokenåˆ·æ–°

**éªŒè¯**ï¼š
```bash
# æ— tokenè®¿é—®
curl http://localhost:8000/protected
# è¿”å›401

# æœ‰tokenè®¿é—®
curl -H "Authorization: Bearer <token>" http://localhost:8000/protected
# è¿”å›200
```

---

### ç»ƒä¹ 2ï¼šæ•æ„Ÿæ•°æ®åŠ å¯†

**ä»»åŠ¡**ï¼š
1. åŠ å¯†æ•æ„Ÿå­—æ®µ
2. å®ç°å¯†é’¥ç®¡ç†
3. æµ‹è¯•åŠ è§£å¯†æµç¨‹

**éªŒè¯**ï¼š
```python
# æµ‹è¯•åŠ å¯†
encrypted = encrypt_data("secret")
assert decrypt_data(encrypted) == "secret"
```

---

### ç»ƒä¹ 3ï¼šé€Ÿç‡é™åˆ¶

**ä»»åŠ¡**ï¼š
1. å®ç°é€Ÿç‡é™åˆ¶
2. æµ‹è¯•é™åˆ¶æ•ˆæœ
3. é…ç½®ä¸åŒé™åˆ¶ç­–ç•¥

**éªŒè¯**ï¼š
```bash
# å‘é€100ä¸ªè¯·æ±‚
for i in {1..100}; do curl http://localhost:8000/query; done

# ç¬¬101ä¸ªè¯·æ±‚åº”è¯¥è¿”å›429
```

---

## 9. å®‰å…¨æœ€ä½³å®è·µ

### 9.1 å®‰å…¨æ£€æŸ¥æ¸…å•

- âœ… æ‰€æœ‰APIç«¯ç‚¹éƒ½æœ‰è®¤è¯
- âœ… æ•æ„Ÿæ•°æ®å·²åŠ å¯†
- âœ… è¾“å…¥å·²éªŒè¯å’Œæ¸…ç†
- âœ… å®æ–½äº†é€Ÿç‡é™åˆ¶
- âœ… å®šæœŸæ›´æ–°ä¾èµ–
- âœ… å¯ç”¨äº†æ—¥å¿—å’Œç›‘æ§
- âœ… é…ç½®äº†CORSç­–ç•¥
- âœ… ä½¿ç”¨HTTPS
- âœ… å®šæœŸå®‰å…¨æ‰«æ
- âœ… åº”æ€¥å“åº”é¢„æ¡ˆ

### 9.2 å®‰å…¨é…ç½®

```python
# CORSé…ç½®
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://yourdomain.com"],  # é™åˆ¶åŸŸå
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)

# å®‰å…¨å¤´
from fastapi.middleware.trustedhost import TrustedHostMiddleware

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["yourdomain.com", "*.yourdomain.com"]
)
```

---

## 10. æ€»ç»“

### å…³é”®è¦ç‚¹

1. **è®¤è¯æˆæƒ**
   - JWTè®¤è¯
   - APIå¯†é’¥
   - OAuth2

2. **æ•°æ®ä¿æŠ¤**
   - æ•æ„Ÿæ•°æ®åŠ å¯†
   - Secretç®¡ç†
   - å®‰å…¨å­˜å‚¨

3. **é˜²æŠ¤æªæ–½**
   - è¾“å…¥éªŒè¯
   - é€Ÿç‡é™åˆ¶
   - é˜²æ³¨å…¥æ”»å‡»

### ä¸‹ä¸€æ­¥

- å­¦ä¹ æœ€ä½³å®è·µï¼ˆç¬¬23ç« ï¼‰

---

**æ­å–œå®Œæˆç¬¬22ç« ï¼** ğŸ‰

ä½ å·²ç»æŒæ¡RAGç³»ç»Ÿå®‰å…¨çš„å„é¡¹æŠ€èƒ½ï¼

**ä¸‹ä¸€æ­¥**ï¼šç¬¬23ç«  - æœ€ä½³å®è·µå’Œæ¡ˆä¾‹åˆ†æ
