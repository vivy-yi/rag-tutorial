# 模块4练习题参考答案

> 提供详细的解答和代码示例

---

## 练习1：优化Dockerfile

### 优化后的Dockerfile

```dockerfile
# 多阶段构建
FROM python:3.10-slim as builder

WORKDIR /app

# 安装构建依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 复制并安装依赖
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# 运行阶段
FROM python:3.10-slim

WORKDIR /app

# 从构建阶段复制
COPY --from=builder /root/.local /root/.local
ENV PATH=/root/.local/bin:$PATH

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/health')" || exit 1

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 优化效果

- **镜像大小**：从900MB减少到150MB
- **构建时间**：利用缓存，第二次构建减少50%
- **安全性**：非root用户运行

---

## 练习2：多服务Docker Compose

### docker-compose.yml

```yaml
version: '3.8'

services:
  rag-api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: rag-api
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://raguser:ragpass@postgres:5432/ragdb
      - CHROMA_HOST=chromadb
      - CHROMA_PORT=8000
    depends_on:
      postgres:
        condition: service_healthy
      chromadb:
        condition: service_started
    volumes:
      - ./app:/app
    networks:
      - rag-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  postgres:
    image: postgres:15-alpine
    container_name: rag-postgres
    environment:
      - POSTGRES_USER=raguser
      - POSTGRES_PASSWORD=ragpass
      - POSTGRES_DB=ragdb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - rag-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U raguser"]
      interval: 10s
      timeout: 5s
      retries: 5

  chromadb:
    image: chromadb/chroma:latest
    container_name: rag-chromadb
    ports:
      - "8001:8000"
    volumes:
      - chroma_data:/chroma/chroma
    networks:
      - rag-network
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    container_name: rag-nginx
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - rag-api
    networks:
      - rag-network
    restart: unless-stopped

volumes:
  postgres_data:
  chroma_data:

networks:
  rag-network:
    driver: bridge
```

### 启动命令

```bash
# 启动所有服务
docker-compose up -d

# 查看状态
docker-compose ps

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down
```

---

## 练习3：Docker安全扫描

### 扫描命令

```bash
# 安装Trivy
brew install trivy

# 扫描镜像
trivy image python:3.10-slim

# 生成报告
trivy image --format json --output report.json your-image:latest

# 扫描并修复
trivy image --severity HIGH,CRITICAL your-image:latest
```

### 修复措施

1. **更新基础镜像**：使用最新版本
2. **删除不需要的包**：减少攻击面
3. **扫描依赖**：`pip-audit`或`safety check`
4. **使用非root用户**：最小权限原则

---

## 练习4：部署RAG API到K8s

### deployment.yaml

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rag-api
  namespace: rag-system
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  selector:
    matchLabels:
      app: rag-api
  template:
    metadata:
      labels:
        app: rag-api
    spec:
      containers:
      - name: rag-api
        image: rag-api:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            configMapKeyRef:
              name: rag-config
              key: database-url
        - name: DATABASE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: rag-secret
              key: database-password
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 5
```

### 部署命令

```bash
# 创建命名空间
kubectl create namespace rag-system

# 应用配置
kubectl apply -f deployment.yaml

# 查看状态
kubectl get pods -n rag-system

# 查看日志
kubectl logs -f deployment/rag-api -n rag-system
```

---

## 练习7：配置Prometheus监控

### 添加指标代码

```python
from prometheus_client import Counter, Histogram, Gauge

# 定义指标
query_counter = Counter('rag_queries_total', 'Total queries', ['status'])
query_duration = Histogram('rag_query_duration_seconds', 'Query duration')
active_queries = Gauge('rag_active_queries', 'Active queries')

# 在应用中使用
@app.post("/query")
async def query(text: str):
    active_queries.inc()
    with query_duration.time():
        try:
            result = await rag_query(text)
            query_counter.labels(status='success').inc()
            return result
        except Exception as e:
            query_counter.labels(status='error').inc()
            raise
        finally:
            active_queries.dec()
```

### Prometheus配置

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'rag-api'
    static_configs:
      - targets: ['rag-api-service:8000']
    metrics_path: /metrics
```

---

## 练习13：实施多层缓存

### Redis缓存实现

```python
import redis
import pickle
from typing import Optional

redis_client = redis.Redis(host='localhost', port=6379, db=0)

class QueryCache:
    def __init__(self, ttl: int = 1800):
        self.ttl = ttl
    
    async def get(self, query: str) -> Optional[dict]:
        # L1: 内存缓存
        if query in self.memory_cache:
            return self.memory_cache[query]
        
        # L2: Redis缓存
        cached = redis_client.get(f"query:{query}")
        if cached:
            result = pickle.loads(cached)
            self.memory_cache[query] = result
            return result
        
        return None
    
    async def set(self, query: str, result: dict):
        # 内存缓存（LRU）
        if len(self.memory_cache) > 1000:
            del self.memory_cache[next(iter(self.memory_cache))]
        self.memory_cache[query] = result
        
        # Redis缓存
        redis_client.setex(
            f"query:{query}",
            self.ttl,
            pickle.dumps(result)
        )
```

---

## 总结

以上是部分练习的参考答案。完整答案代码较长，建议：

1. 动手实践每个练习
2. 参考示例代码理解要点
3. 根据实际情况调整
4. 记录遇到的问题和解决方案

**记住**：生产部署需要综合考虑安全、性能、可维护性等多方面因素。
