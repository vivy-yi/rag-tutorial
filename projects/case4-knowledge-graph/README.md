# æ¡ˆä¾‹4ï¼šä¼ä¸šçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿ

> æ„å»ºåŸºäºçŸ¥è¯†å›¾è°±çš„ä¼ä¸šçº§é—®ç­”ç³»ç»Ÿï¼Œå®ç°å¤æ‚å…³ç³»æ¨ç†å’Œå¤šè·³æŸ¥è¯¢

---

## ğŸ“‹ æ¡ˆä¾‹æ¦‚è¿°

### ä¸šåŠ¡åœºæ™¯

å¤§å‹ä¼ä¸šé¢ä¸´çŸ¥è¯†ç®¡ç†æŒ‘æˆ˜ï¼š
- âœ— çŸ¥è¯†åˆ†æ•£åœ¨å„ä¸ªç³»ç»Ÿ
- âœ— å‘˜å·¥éš¾ä»¥æ‰¾åˆ°ç›¸å…³ä¿¡æ¯
- âœ— çŸ¥è¯†å…³ç³»å¤æ‚éš¾ç†è§£
- âœ— æ–°å‘˜å·¥åŸ¹è®­å‘¨æœŸé•¿

### GraphRAGè§£å†³æ–¹æ¡ˆ

æ„å»ºä¼ä¸šçŸ¥è¯†å›¾è°±é—®ç­”ç³»ç»Ÿï¼š
- âœ… ç»Ÿä¸€çŸ¥è¯†è¡¨ç¤º
- âœ… å¤æ‚å…³ç³»æ¨ç†
- âœ… å¯è§†åŒ–çŸ¥è¯†æ¢ç´¢
- âœ… æ™ºèƒ½é—®ç­”äº¤äº’

---

## ğŸ¯ åŠŸèƒ½éœ€æ±‚

### æ ¸å¿ƒåŠŸèƒ½

1. **çŸ¥è¯†å›¾è°±æ„å»º**
   - ä»æ–‡æ¡£æå–å®ä½“å’Œå…³ç³»
   - å¤šæºçŸ¥è¯†èåˆ
   - å›¾è°±å¯è§†åŒ–
   - åŠ¨æ€æ›´æ–°

2. **æ™ºèƒ½é—®ç­”**
   - è‡ªç„¶è¯­è¨€æŸ¥è¯¢
   - å¤šè·³æ¨ç†
   - å…³ç³»è·¯å¾„å±•ç¤º
   - ç­”æ¡ˆè§£é‡Š

3. **çŸ¥è¯†æ¢ç´¢**
   - å®ä½“å…³ç³»å¯¼èˆª
   - å›¾è°±æµè§ˆ
   - ç›¸å…³çŸ¥è¯†æ¨è
   - çŸ¥è¯†ä¾èµ–åˆ†æ

4. **å›¾è°±ç®¡ç†**
   - å®ä½“/å…³ç³»å¢åˆ æ”¹
   - æ•°æ®å¯¼å…¥å¯¼å‡º
   - ç‰ˆæœ¬æ§åˆ¶
   - æƒé™ç®¡ç†

---

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Webç•Œé¢ (React/D3.js)            â”‚
â”‚  - çŸ¥è¯†å›¾è°±å¯è§†åŒ–                         â”‚
â”‚  - é—®ç­”äº¤äº’                               â”‚
â”‚  - å®ä½“è¯¦æƒ…å±•ç¤º                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          APIæœåŠ¡ (FastAPI)               â”‚
â”‚  - å›¾è°±æŸ¥è¯¢æ¥å£                           â”‚
â”‚  - é—®ç­”å¤„ç†                               â”‚
â”‚  - æ•°æ®ç®¡ç†                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚å›¾è°±æ£€ç´¢â”‚      â”‚  LLMç”Ÿæˆ   â”‚
    â”‚(Neo4j) â”‚      â”‚  (GPT-4)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ

**å›¾è°±å­˜å‚¨**ï¼š
- Neo4j (å›¾æ•°æ®åº“)
- NetworkX (å›¾è®¡ç®—)

**NLPå¤„ç†**ï¼š
- spaCy (å®ä½“è¯†åˆ«)
- LangChain (å›¾è°±é›†æˆ)
- OpenAI GPT-4

**åç«¯**ï¼š
- FastAPI
- PyNeo4j (Neo4jé©±åŠ¨)

**å‰ç«¯**ï¼š
- React
- D3.js / Cytoscape.js (å¯è§†åŒ–)
- Ant Design

---

## ğŸ’» æ ¸å¿ƒå®ç°

### 1. çŸ¥è¯†å›¾è°±æ„å»º

```python
# graph_builder.py
from neo4j import GraphDatabase
from typing import List, Dict, Tuple
import spacy

class EnterpriseKnowledgeGraph:
    """
    ä¼ä¸šçŸ¥è¯†å›¾è°±æ„å»ºå™¨
    """

    def __init__(self, uri: str, user: str, password: str):
        """
        åˆå§‹åŒ–Neo4jè¿æ¥

        Args:
            uri: Neo4j URI
            user: ç”¨æˆ·å
            password: å¯†ç 
        """
        self.driver = GraphDatabase.driver(
            uri,
            auth=(user, password)
        )

        # åŠ è½½NERæ¨¡å‹
        self.nlp = spacy.load("zh_core_web_sm")

    def close(self):
        """å…³é—­è¿æ¥"""
        self.driver.close()

    def create_constraints(self):
        """åˆ›å»ºçº¦æŸå’Œç´¢å¼•"""
        with self.driver.session() as session:
            # å”¯ä¸€çº¦æŸ
            session.run("""
                CREATE CONSTRAINT entity_id_unique
                IF NOT EXISTS FOR (e:Entity)
                REQUIRE e.id IS UNIQUE
            """)

            # ç´¢å¼•
            session.run("""
                CREATE INDEX entity_name_index
                IF NOT EXISTS FOR (e:Entity)
                ON (e.name)
            """)

    def add_entity(self,
                   entity_id: str,
                   name: str,
                   entity_type: str,
                   properties: Dict = None):
        """
        æ·»åŠ å®ä½“

        Args:
            entity_id: å®ä½“ID
            name: å®ä½“åç§°
            entity_type: å®ä½“ç±»å‹
            properties: å…¶ä»–å±æ€§
        """
        with self.driver.session() as session:
            query = """
                MERGE (e:Entity:$type {id: $id})
                SET e.name = $name,
                    e.updated_at = datetime()
            """

            params = {
                "id": entity_id,
                "type": entity_type,
                "name": name
            }

            if properties:
                for key, value in properties.items():
                    query += f", e.{key} = ${key}"
                    params[key] = value

            session.run(query, params)

    def add_relation(self,
                    source_id: str,
                    target_id: str,
                    relation_type: str,
                    properties: Dict = None):
        """
        æ·»åŠ å…³ç³»

        Args:
            source_id: æºå®ä½“ID
            target_id: ç›®æ ‡å®ä½“ID
            relation_type: å…³ç³»ç±»å‹
            properties: å…³ç³»å±æ€§
        """
        with self.driver.session() as session:
            query = """
                MATCH (source:Entity {id: $source_id})
                MATCH (target:Entity {id: $target_id})
                MERGE (source)-[r:$type]->(target)
                SET r.updated_at = datetime()
            """

            params = {
                "source_id": source_id,
                "target_id": target_id,
                "type": relation_type
            }

            if properties:
                for key, value in properties.items():
                    query += f", r.{key} = ${key}"
                    params[key] = value

            session.run(query, params)

    def extract_from_document(self,
                            document: str,
                            doc_id: str) -> Tuple[int, int]:
        """
        ä»æ–‡æ¡£ä¸­æå–çŸ¥è¯†

        Args:
            document: æ–‡æ¡£æ–‡æœ¬
            doc_id: æ–‡æ¡£ID

        Returns:
            (å®ä½“æ•°, å…³ç³»æ•°)
        """
        # NLPå¤„ç†
        doc = self.nlp(document)

        # æå–å®ä½“ï¼ˆç®€åŒ–ç‰ˆï¼‰
        entities = []
        for ent in doc.ents:
            if ent.label_ in ["PERSON", "ORG", "PRODUCT", "TECH"]:
                entity_id = f"{doc_id}_{ent.start_char}"

                self.add_entity(
                    entity_id=entity_id,
                    name=ent.text,
                    entity_type=ent.label_,
                    properties={
                        "source_doc": doc_id,
                        "confidence": 0.9
                    }
                )

                entities.append({
                    "id": entity_id,
                    "text": ent.text,
                    "label": ent.label_
                })

        # æå–å…³ç³»ï¼ˆåŸºäºä¾å­˜å…³ç³»ï¼‰
        relations = []
        for token in doc:
            if token.dep_ in ["nsubj", "dobj", "pobj"]:
                # ç®€åŒ–ï¼šå‡è®¾ç›¸é‚»å®ä½“æœ‰å…³ç³»
                head_text = token.head.text
                dep_text = token.text

                # æŸ¥æ‰¾å¯¹åº”çš„å®ä½“
                head_entity = next(
                    (e for e in entities if e["text"] == head_text),
                    None
                )
                dep_entity = next(
                    (e for e in entities if e["text"] == dep_text),
                    None
                )

                if head_entity and dep_entity:
                    self.add_relation(
                        source_id=head_entity["id"],
                        target_id=dep_entity["id"],
                        relation_type=token.dep_,
                        properties={"source_doc": doc_id}
                    )
                    relations.append(1)

        return len(entities), len(relations)

    def import_from_json(self, json_file: str):
        """
        ä»JSONå¯¼å…¥çŸ¥è¯†å›¾è°±

        JSONæ ¼å¼:
        {
            "entities": [
                {"id": "E1", "name": "å¼ ä¸‰", "type": "Person"},
                ...
            ],
            "relations": [
                {"source": "E1", "target": "E2", "type": "å·¥ä½œäº"},
                ...
            ]
        }
        """
        import json

        with open(json_file, 'r', encoding='utf-8') as f:
            data = json.load(f)

        # æ·»åŠ å®ä½“
        for entity in data.get("entities", []):
            self.add_entity(
                entity_id=entity["id"],
                name=entity["name"],
                entity_type=entity["type"],
                properties=entity.get("properties", {})
            )

        # æ·»åŠ å…³ç³»
        for relation in data.get("relations", []):
            self.add_relation(
                source_id=relation["source"],
                target_id=relation["target"],
                relation_type=relation["type"],
                properties=relation.get("properties", {})
            )
```

### 2. GraphRAGæŸ¥è¯¢

```python
# graph_rag_query.py
from typing import List, Dict, Optional
from neo4j import GraphDatabase

class GraphRAGQuery:
    """
    åŸºäºçŸ¥è¯†å›¾è°±çš„RAGæŸ¥è¯¢
    """

    def __init__(self, kg: EnterpriseKnowledgeGraph):
        """
        åˆå§‹åŒ–

        Args:
            kg: çŸ¥è¯†å›¾è°±å®ä¾‹
        """
        self.kg = kg

    def query(self,
             question: str,
             max_hops: int = 3) -> Dict:
        """
        æ‰§è¡ŒæŸ¥è¯¢

        Args:
            question: è‡ªç„¶è¯­è¨€é—®é¢˜
            max_hops: æœ€å¤§è·³æ•°

        Returns:
            æŸ¥è¯¢ç»“æœ
        """
        # 1. è¯†åˆ«å®ä½“
        entities = self._extract_entities(question)

        if not entities:
            return {
                "answer": "æŠ±æ­‰ï¼Œæˆ‘æ— æ³•è¯†åˆ«é—®é¢˜ä¸­çš„å®ä½“",
                "paths": []
            }

        # 2. å›¾è°±æ£€ç´¢
        paths = self._graph_retrieve(entities, max_hops)

        # 3. æ„å»ºä¸Šä¸‹æ–‡
        context = self._build_context(paths)

        # 4. ç”Ÿæˆç­”æ¡ˆ
        answer = self._generate_answer(question, context, paths)

        return {
            "answer": answer,
            "entities": entities,
            "paths": paths,
            "context": context
        }

    def _extract_entities(self, text: str) -> List[str]:
        """ä»æ–‡æœ¬ä¸­æå–å®ä½“ID"""
        # ä½¿ç”¨NERæå–å®ä½“åç§°
        doc = self.kg.nlp(text)
        entity_names = [ent.text for ent in doc.ents]

        # åœ¨å›¾è°±ä¸­æŸ¥æ‰¾
        entity_ids = []
        with self.kg.driver.session() as session:
            for name in entity_names:
                result = session.run("""
                    MATCH (e:Entity)
                    WHERE e.name CONTAINS $name
                    RETURN e.id as id
                    LIMIT 1
                """, {"name": name})

                record = result.single()
                if record:
                    entity_ids.append(record["id"])

        return entity_ids

    def _graph_retrieve(self,
                       entity_ids: List[str],
                       max_hops: int) -> List[Dict]:
        """
        å›¾è°±æ£€ç´¢ï¼šå¤šè·³è·¯å¾„æŸ¥æ‰¾

        Args:
            entity_ids: èµ·å§‹å®ä½“IDåˆ—è¡¨
            max_hops: æœ€å¤§è·³æ•°

        Returns:
            è·¯å¾„åˆ—è¡¨
        """
        paths = []

        with self.kg.driver.session() as session:
            for entity_id in entity_ids:
                # æŸ¥æ‰¾æ‰€æœ‰è·¯å¾„
                query = """
                    MATCH path = (start:Entity {id: $entity_id})-[*1..{max_hops}]-(end:Entity)
                    RETURN [node in nodes(path) | {
                        id: node.id,
                        name: node.name,
                        type: labels(node)[0]
                    }] as nodes,
                    [rel in relationships(path) | {
                        type: type(rel),
                        source: startNode(rel).id,
                        target: endNode(rel).id
                    }] as rels
                    ORDER BY length(path)
                    LIMIT 10
                """

                result = session.run(
                    query,
                    {"entity_id": entity_id, "max_hops": max_hops}
                )

                for record in result:
                    paths.append({
                        "nodes": record["nodes"],
                        "rels": record["rels"]
                    })

        return paths

    def _build_context(self, paths: List[Dict]) -> str:
        """æ„å»ºä¸Šä¸‹æ–‡æ–‡æœ¬"""
        if not paths:
            return "æœªæ‰¾åˆ°ç›¸å…³çŸ¥è¯†"

        context_parts = []

        for i, path in enumerate(paths[:5], 1):
            # æ„å»ºè·¯å¾„æè¿°
            nodes = path["nodes"]
            path_str = " â†’ ".join([n["name"] for n in nodes])

            context_parts.append(f"è·¯å¾„{i}: {path_str}")

        return "\n".join(context_parts)

    def _generate_answer(self,
                        question: str,
                        context: str,
                        paths: List[Dict]) -> str:
        """
        ç”Ÿæˆç­”æ¡ˆ

        è¿™é‡Œå¯ä»¥ä½¿ç”¨LLMï¼Œä¹Ÿå¯ä»¥ç”¨è§„åˆ™
        """
        # è§„åˆ™ç”Ÿæˆï¼ˆç®€åŒ–ç‰ˆï¼‰
        answer_parts = [f"åŸºäºçŸ¥è¯†å›¾è°±ï¼Œæ‰¾åˆ°ä»¥ä¸‹ä¿¡æ¯ï¼š\n"]
        answer_parts.append(context)

        if paths:
            answer_parts.append("\nä¸»è¦å‘ç°ï¼š")
            for i, path in enumerate(paths[:3], 1):
                nodes = path["nodes"]
                answer_parts.append(f"{i}. {nodes[0]['name']}åˆ°{nodes[-1]['name']}çš„å…³ç³»è·¯å¾„")

        return "\n".join(answer_parts)
```

### 3. å¯è§†åŒ–æ¥å£

```python
# api/visualization.py
from fastapi import FastAPI, Query
from typing import List, Dict
from neo4j import GraphDatabase

app = FastAPI(title="çŸ¥è¯†å›¾è°±å¯è§†åŒ–API")

@app.get("/api/graph/subgraph")
async def get_subgraph(
    entity_id: str = Query(..., description="ä¸­å¿ƒå®ä½“ID"),
    hops: int = Query(2, description="è·³æ•°")
):
    """
    è·å–å­å›¾ç”¨äºå¯è§†åŒ–

    Returns:
        èŠ‚ç‚¹å’Œè¾¹çš„åˆ—è¡¨
    """
    driver = GraphDatabase.driver(
        "bolt://localhost:7687",
        auth=("neo4j", "password")
    )

    try:
        with driver.session() as session:
            # æŸ¥è¯¢å­å›¾
            query = """
                MATCH path = (start:Entity {id: $entity_id})-[*1..$hops]-(end:Entity)
                WITH nodes(path) as nodes,
                     relationships(path) as rels
                UNWIND nodes as node
                WITH collect(DISTINCT node) as all_nodes,
                     rels
                UNWIND rels as rel
                RETURN all_nodes as nodes,
                       collect(DISTINCT rel) as relationships
            """

            result = session.run(
                query,
                {"entity_id": entity_id, "hops": hops}
            )

            record = result.single()

            # æ ¼å¼åŒ–èŠ‚ç‚¹
            nodes = []
            for node in record["nodes"]:
                nodes.append({
                    "id": node["id"],
                    "label": node["name"],
                    "type": list(node.labels())[0]
                })

            # æ ¼å¼åŒ–è¾¹
            edges = []
            for rel in record["relationships"]:
                edges.append({
                    "source": rel.start_node["id"],
                    "target": rel.end_node["id"],
                    "label": type(rel).__name__
                })

            return {
                "nodes": nodes,
                "edges": edges
            }

    finally:
        driver.close()

@app.get("/api/graph/entity/{entity_id}")
async def get_entity_details(entity_id: str):
    """è·å–å®ä½“è¯¦æƒ…"""
    driver = GraphDatabase.driver(
        "bolt://localhost:7687",
        auth=("neo4j", "password")
    )

    try:
        with driver.session() as session:
            result = session.run("""
                MATCH (e:Entity {id: $entity_id})
                OPTIONAL MATCH (e)-[r]-(related:Entity)
                RETURN e as entity,
                       collect(DISTINCT {
                           id: related.id,
                           name: related.name,
                           type: labels(related)[0],
                           relation: type(r)
                       }) as relations
            """, {"entity_id": entity_id})

            record = result.single()

            entity = record["entity"]
            relations = record["relations"]

            return {
                "id": entity["id"],
                "name": entity["name"],
                "type": list(entity.labels())[0],
                "properties": dict(entity),
                "relations": relations
            }

    finally:
        driver.close()
```

### 4. Reactå‰ç«¯ç»„ä»¶

```javascript
// frontend/src/components/GraphVisualization.jsx
import React, { useEffect, useState } from 'react';
import cytoscape from 'cytoscape';
import CytoscapeComponent from 'react-cytoscapejs';

const GraphVisualization = ({ entityId }) => {
  const [elements, setElements] = useState({ nodes: [], edges: [] });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchSubgraph();
  }, [entityId]);

  const fetchSubgraph = async () => {
    setLoading(true);
    try {
      const response = await fetch(
        `/api/graph/subgraph?entity_id=${entityId}&hops=2`
      );
      const data = await response.json();

      // è½¬æ¢ä¸ºCytoscapeæ ¼å¼
      const elements = [
        ...data.nodes.map(node => ({
          data: {
            id: node.id,
            label: node.label,
            type: node.type
          }
        })),
        ...data.edges.map(edge => ({
          data: {
            id: `${edge.source}-${edge.target}`,
            source: edge.source,
            target: edge.target,
            label: edge.label
          }
        }))
      ];

      setElements(elements);
    } catch (error) {
      console.error('Error fetching graph:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  const layout = {
    name: 'cose',
    animate: true,
    nodeDimensionsIncludeLabels: true
  };

  const stylesheet = [
    {
      selector: 'node',
      style: {
        'background-color': '#666',
        'label': 'data(label)',
        'width': 30,
        'height': 30
      }
    },
    {
      selector: 'node[type="Person"]',
      style: {
        'background-color': '#FF6B6B'
      }
    },
    {
      selector: 'node[type="Organization"]',
      style: {
        'background-color': '#4ECDC4'
      }
    },
    {
      selector: 'edge',
      style: {
        'width': 2,
        'line-color': '#ccc',
        'target-arrow-color': '#ccc',
        'target-arrow-shape': 'triangle'
      }
    }
  ];

  return (
    <div style={{ height: '600px' }}>
      <CytoscapeComponent
        elements={elements}
        style={{ width: '100%', height: '100%' }}
        zoomingEnabled={true}
        maxZoom={3}
        minZoom={0.1}
        autounselectify={true}
        layout={layout}
        stylesheet={stylesheet}
      />
    </div>
  );
};

export default GraphVisualization;
```

---

## ğŸ“Š æ•°æ®ç¤ºä¾‹

### ä¼ä¸šçŸ¥è¯†å›¾è°±æ•°æ®ç»“æ„

```json
{
  "entities": [
    {
      "id": "E001",
      "name": "å¼ ä¸‰",
      "type": "Person",
      "properties": {
        "department": "æŠ€æœ¯éƒ¨",
        "position": "é«˜çº§å·¥ç¨‹å¸ˆ",
        "email": "zhangsan@company.com"
      }
    },
    {
      "id": "E002",
      "name": "æå››",
      "type": "Person",
      "properties": {
        "department": "äº§å“éƒ¨",
        "position": "äº§å“ç»ç†",
        "email": "lisi@company.com"
      }
    },
    {
      "id": "E003",
      "name": "RAGç³»ç»Ÿ",
      "type": "Project",
      "properties": {
        "status": "è¿›è¡Œä¸­",
        "priority": "é«˜"
      }
    },
    {
      "id": "E004",
      "name": "æŠ€æœ¯éƒ¨",
      "type": "Department",
      "properties": {
        "location": "3æ¥¼",
        "head": "ç‹äº”"
      }
    }
  ],
  "relations": [
    {
      "source": "E001",
      "target": "E003",
      "type": "è´Ÿè´£",
      "properties": {
        "role": "æŠ€æœ¯è´Ÿè´£äºº",
        "since": "2024-01"
      }
    },
    {
      "source": "E002",
      "target": "E003",
      "type": "ç®¡ç†",
      "properties": {
        "role": "äº§å“ç»ç†"
      }
    },
    {
      "source": "E001",
      "target": "E004",
      "type": "éš¶å±",
      "properties": {}
    },
    {
      "source": "E002",
      "target": "E004",
      "type": "åä½œ",
      "properties": {
        "frequency": "æ¯å‘¨ä¼šè®®"
      }
    }
  ]
}
```

---

## ğŸ§ª æµ‹è¯•åœºæ™¯

### åœºæ™¯1ï¼šå‘˜å·¥ä¿¡æ¯æŸ¥è¯¢

**é—®é¢˜**ï¼š"å¼ ä¸‰è´Ÿè´£å“ªäº›é¡¹ç›®ï¼Ÿ"

**æ‰§è¡Œæµç¨‹**ï¼š
1. è¯†åˆ«å®ä½“ï¼šå¼ ä¸‰
2. å›¾è°±æ£€ç´¢ï¼š
   ```
   å¼ ä¸‰ -[è´Ÿè´£]-> RAGç³»ç»Ÿ
   å¼ ä¸‰ -[è´Ÿè´£]-> çŸ¥è¯†å›¾è°±ç³»ç»Ÿ
   ```
3. ç­”æ¡ˆç”Ÿæˆ

### åœºæ™¯2ï¼šå…³ç³»æ¨ç†

**é—®é¢˜**ï¼š"æå››å’Œå¼ ä¸‰æœ‰åˆä½œå—ï¼Ÿ"

**æ‰§è¡Œæµç¨‹**ï¼š
1. è¯†åˆ«å®ä½“ï¼šæå››ã€å¼ ä¸‰
2. å¤šè·³æ£€ç´¢ï¼š
   ```
   æå›› -[ç®¡ç†]-> RAGç³»ç»Ÿ <-[è´Ÿè´£]- å¼ ä¸‰
   ```
3. æ¨ç†ï¼šä¸¤äººå…±åŒå‚ä¸RAGç³»ç»Ÿé¡¹ç›®

### åœºæ™¯3ï¼šç»„ç»‡åˆ†æ

**é—®é¢˜**ï¼š"æŠ€æœ¯éƒ¨æœ‰å“ªäº›äººï¼Ÿ"

**æ‰§è¡Œæµç¨‹**ï¼š
1. è¯†åˆ«å®ä½“ï¼šæŠ€æœ¯éƒ¨
2. å›¾è°±æ£€ç´¢æ‰€æœ‰éš¶å±å…³ç³»
3. è¿”å›æ‰€æœ‰æŠ€æœ¯äººå‘˜

---

## ğŸ¨ å¯è§†åŒ–ç¤ºä¾‹

### å›¾è°±å±•ç¤º

ä½¿ç”¨D3.jsæˆ–Cytoscape.jså±•ç¤ºï¼š

```javascript
// èŠ‚ç‚¹æ ·å¼é…ç½®
const nodeStyles = {
  'Person': { color: '#FF6B6B', icon: 'user' },
  'Organization': { color: '#4ECDC4', icon: 'building' },
  'Project': { color: '#45B7D1', icon: 'folder' },
  'Technology': { color: '#96CEB4', icon: 'code' }
};

// åŠ›å¯¼å‘å¸ƒå±€
const layout = {
  type: 'force',
  nodeSpacing: 100,
  linkDistance: 150
};

// äº¤äº’åŠŸèƒ½
const interactions = {
  zoom: true,
  drag: true,
  hover: true,
  click: (node) => {
    showEntityDetails(node.id);
  }
};
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### 1. å›¾è°±ç´¢å¼•

```python
# åˆ›å»ºç´¢å¼•
def create_indexes():
    indexes = [
        "CREATE INDEX ON :Entity(name)",
        "CREATE INDEX ON :Entity(type)",
        "CREATE INDEX ON :Entity(updated_at)"
    ]

    for index in indexes:
        session.run(index)
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

```python
# ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
def optimized_query(entity_ids: List[str]):
    query = """
        MATCH (e:Entity)
        WHERE e.id IN $entity_ids
        RETURN e
    """

    session.run(query, entity_ids=entity_ids)
```

### 3. ç¼“å­˜å±‚

```python
from functools import lru_cache

@lru_cache(maxsize=100)
def get_entity(entity_id: str):
    """ç¼“å­˜å®ä½“æŸ¥è¯¢"""
    return fetch_entity_from_neo4j(entity_id)
```

---

## ğŸš€ éƒ¨ç½²æŒ‡å—

### Docker Compose

```yaml
version: '3.8'

services:
  neo4j:
    image: neo4j:5.0
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
    volumes:
      - neo4j_data:/data

  api:
    build: ./api
    ports:
      - "8000:8000"
    depends_on:
      - neo4j
    environment:
      - NEO4J_URI=bolt://neo4j:7687
      - NEO4J_USER=neo4j
      - NEO4J_PASSWORD=password

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - api

volumes:
  neo4j_data:
```

---

## ğŸ“ å­¦ä¹ è¦ç‚¹

å®Œæˆæœ¬æ¡ˆä¾‹åï¼Œä½ å°†æŒæ¡ï¼š

### âœ… çŸ¥è¯†å›¾è°±
- Neo4jå›¾æ•°æ®åº“
- å›¾è°±å»ºæ¨¡æ–¹æ³•
- CypheræŸ¥è¯¢è¯­è¨€
- å›¾è°±å¯è§†åŒ–

### âœ… GraphRAG
- å®ä½“è¯†åˆ«å’ŒæŠ½å–
- å¤šè·³æ¨ç†ç®—æ³•
- å›¾è°±æ£€ç´¢ä¼˜åŒ–
- ä¸Šä¸‹æ–‡æ„å»º

### âœ… ç³»ç»Ÿè®¾è®¡
- å›¾æ•°æ®åº“æ¶æ„
- APIè®¾è®¡
- å‰åç«¯åˆ†ç¦»
- æ€§èƒ½ä¼˜åŒ–

---

## ğŸš€ è¿›é˜¶æ–¹å‘

1. **é«˜çº§åŠŸèƒ½**
   - å®ä½“æ¶ˆæ­§
   - å…³ç³»æ¨ç†
   - æ—¶åºå›¾è°±
   - å›¾åµŒå…¥

2. **ä¼ä¸šç‰¹æ€§**
   - æƒé™æ§åˆ¶
   - æ•°æ®åŠ å¯†
   - å®¡è®¡æ—¥å¿—
   - å¤‡ä»½æ¢å¤

3. **æ™ºèƒ½å¢å¼º**
   - è‡ªåŠ¨å›¾è°±æ›´æ–°
   - çŸ¥è¯†æ¨è
   - å¼‚å¸¸æ£€æµ‹
   - è¶‹åŠ¿åˆ†æ

---

## ğŸ“š å‚è€ƒèµ„æº

- [Neo4jæ–‡æ¡£](https://neo4j.com/docs/)
- [GraphRAGè®ºæ–‡](https://arxiv.org/abs/2404.16130)
- [spaCy NER](https://spacy.io/usage/linguistic-features/#named-entities)

---

**å¼€å§‹æ„å»ºä½ çš„ä¼ä¸šçŸ¥è¯†å›¾è°±ç³»ç»Ÿå§ï¼** ğŸš€
